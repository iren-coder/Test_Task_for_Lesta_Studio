# Побитовые проверки являются более быстрыми и точными. 

# Проверка с помощью оператора по модулю %.
# Если остаток от деления value на 2 равен 0, значит, value является чётным. В противном случает value нечётное.
def isEvenV1(value): 
    if value % 2 == 0:
        return value
    else:
        return False

 # Проверка с помощью побитового оператора "&". Проверяем, установлен ли последний бит числа. 
 # Если установлен, точисло НЕчётное. Если не установлен, то чётное. Побитовая операция "&" для числа с 1 будет равна 1, 
 # если она нечётная, т.к. последний бит уже установлен.

 # Value & 1 является чётным, в противном случае value нечётное
def isEvenV2(value):
  return (not (value & 1))

# Проверка с помощью побитового оператора "XOR". 
# Побитовая операция "XOR" увеличивает значение числа на 1, если число чётное. 
# В противном случе, оно остаётся неизменным.

# Возвращает True если value является чётным, в противном случае value нечётное
def isEvenV3(value):
    if (value ^ 1 == 1+value):
        return True
    else:
        return False

# Проверка с помощью побитового оператора "ИЛИ". 
# Побитовая операция "ИЛИ" увеличивает значение числа на 1, если число чётное. 
# В противном случе, оно остаётся неизменным.

# Возвращает True если value является чётным, в противном случае value нечётное
def isEvenV4(value):
    if (value | 1 > value):
        return True
    else:
        return False
  

print(isEvenV1(4))
print(isEvenV1(57))
print(isEvenV1(64))

print(isEvenV2(4))
print(isEvenV2(57))
print(isEvenV2(64))

print(isEvenV3(4))
print(isEvenV3(57))
print(isEvenV3(64))

print(isEvenV4(4))
print(isEvenV4(57))
print(isEvenV4(64))
